#!/usr/bin/env ruby
# frozen_string_literal: true

require 'prism'
require 'rbs'
require 'pathname'
require 'fileutils'

# Process Ruby files to generate RBS definitions for Data classes
class Processor
  Source = Data.define(:file, :content, :prism_node)
  RbsOutput = Data.define(:origin_source, :content)

  def initialize(lib_path: 'lib', output_path: 'sig/generated-by-scripts')
    @lib_path = Pathname(lib_path)
    @output_path = Pathname(output_path)
    @data_classes = []
  end

  def process
    rbs_outputs = each_ruby_file.filter_map do |source|
      DataClassRbsGenerator.new.process(source)
    end

    generate_rbs_files(rbs_outputs)
  end

  private

  def each_ruby_file
    puts "Scanning Ruby files in #{@lib_path}..."

    @lib_path.glob('**/*.rb').map do |file|
      puts "Processing #{file}..." if ENV['DEBUG']
      content = file.read

      parsed = Prism.parse(content)

      Source.new(file:, content:, prism_node: parsed.value)
    end
  end

  def generate_rbs_files(rbs_outputs)
    return if rbs_outputs.empty?

    puts "\nGenerating RBS files..."
    FileUtils.mkdir_p(@output_path)

    content = []
    content << '# Generated RBS definitions'
    content << '# This file is automatically generated by script/generate-rbs.rb'
    content << ''
    content.concat(rbs_outputs.map(&:content))

    rbs_content = content.join("\n")
    output_file = @output_path / 'data_classes.rbs'

    File.write(output_file, rbs_content)
    puts "Generated #{output_file}"
  end
end

# Generate RBS definitions for Data classes found in Ruby files
class DataClassRbsGenerator
  DataClass = Data.define(:name, :namespace, :full_name, :attributes, :file)

  # @rbs source: Processor::Source
  # @rbs return: Processor::RbsOutput?
  def process(source)
    visitor = Visitor.new(source)
    source.prism_node.accept(visitor)

    data_classes = visitor.data_classes

    # Remove duplicates by keeping only unique full_name entries
    data_classes.uniq!(&:full_name)

    return if data_classes.empty?

    puts "Found #{data_classes.size} Data classes:"
    data_classes.each do |data_class|
      puts "  - #{data_class.full_name} with attributes: #{data_class.attributes.join(', ')}"
    end

    rbs_content = RbsPrinter.new(data_classes:).generate_rbs_content
    Processor::RbsOutput.new(origin_source: source, content: rbs_content)
  end

  # Visitor to traverse the Prism AST and extract Data class information
  class Visitor < Prism::Visitor
    attr_reader :source #: Source
    attr_reader :data_classes #: Array[DataClass]
    attr_reader :namespace #: Array[Symbol]

    def initialize(source) # rubocop:disable Lint/MissingSuper --- Prism::Visitor has no initialize method
      @source = source
      @data_classes = []
      @namespace = []
    end

    def visit_class_node(node)
      class_name = extract_constant_name(node.constant_path)

      if data_class?(node)
        attributes = extract_data_attributes(node)
        if attributes
          @data_classes << DataClass.new(
            name: class_name,
            namespace: namespace.dup,
            full_name: [*namespace, class_name].join('::'),
            attributes: attributes,
            file: source.file
          )
        end
      end

      in_namespace(class_name) { super }
    end

    def visit_module_node(node)
      module_name = extract_constant_name(node.constant_path)

      in_namespace(module_name) do
        super
      end
    end

    def extract_constant_name(constant_path)
      case constant_path
      when Prism::ConstantReadNode, Prism::ConstantPathNode
        constant_path.name.to_s
      end
    end

    def data_class?(node)
      return false unless node.superclass

      case node.superclass
      when Prism::CallNode
        if node.superclass.receiver.is_a?(Prism::ConstantReadNode) &&
           node.superclass.receiver.name == :Data &&
           node.superclass.name == :define
          return true
        end
      end

      false
    end

    def extract_data_attributes(node)
      return nil unless node.superclass.is_a?(Prism::CallNode)
      return nil unless node.superclass.name == :define

      arguments = node.superclass.arguments
      return nil unless arguments

      attributes = []
      arguments.arguments.each do |arg|
        case arg
        when Prism::SymbolNode
          attributes << arg.value.to_s
        end
      end

      attributes.empty? ? nil : attributes
    end

    # @rbs new_namespace: String?
    def in_namespace(new_namespace)
      if new_namespace
        @namespace << new_namespace
        yield.tap { @namespace.pop }
      else
        yield
      end
    end
  end

  # Print RBS definitions
  class RbsPrinter
    attr_reader :data_classes

    def initialize(data_classes:)
      @data_classes = data_classes
    end

    def generate_rbs_content #: String
      content = []

      @data_classes.group_by(&:namespace).each do |namespace, classes|
        if namespace.empty?
          classes.each do |data_class|
            content << generate_class_rbs(data_class, 0)
            content << ''
          end
        else
          content.concat(generate_namespaced_classes_rbs(namespace, classes, 0))
        end
      end

      content.join("\n")
    end

    def generate_namespaced_classes_rbs(namespace, classes, indent_level)
      content = []

      namespace.each_with_index do |ns, index|
        content << indent("module #{ns}", level: indent_level + index)
      end

      classes.each do |data_class|
        content << generate_class_rbs(data_class, indent_level + namespace.size)
        content << ''
      end

      namespace.reverse.each_with_index do |_ns, index|
        content << indent('end', level: indent_level + namespace.size - index - 1)
      end

      content << ''
      content
    end

    def generate_class_rbs(data_class, indent_level)
      content = []
      content << indent("class #{data_class.name} < Data", level: indent_level)

      data_class.attributes.each do |attr|
        content << indent("def #{attr}: () -> untyped", level: indent_level + 1)
      end

      content << indent("def initialize: (#{generate_initialize_signature(data_class.attributes)}) -> void", level: indent_level + 1)
      content << indent('end', level: indent_level)

      content.join("\n")
    end

    def generate_initialize_signature(attributes)
      attributes.map { |attr| "#{attr}: untyped" }.join(', ')
    end

    def indent(string, level:)
      ('  ' * level) + string
    end
  end
end

Processor.new.process if __FILE__ == $PROGRAM_NAME
