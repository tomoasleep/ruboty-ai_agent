#!/usr/bin/env ruby
# frozen_string_literal: true

# Generate RBS instance variable definitions for memorized methods
#
# This script detects methods with @rbs %a{memorized} annotation and generates
# corresponding instance variable RBS definitions.
#
# Example Ruby code that this script detects:
#
#   class User
#     # @rbs %a{memorized}
#     def profile #: Profile
#       @profile ||= Profile.find(user_id: id)
#     end
#
#     # @rbs %a{memorized}
#     def settings #: Settings
#       @settings ||= Settings.new(user: self)
#     end
#   end
#
# This will generate:
#
#   class User
#     @profile: Profile
#     @settings: Settings
#   end
#
# The script:
# 1. Looks for methods with @rbs %a{memorized} annotation
# 2. Extracts instance variable names from @ivar ||= patterns
# 3. Gets return type from method signature comment (#: Type)
# 4. Generates RBS definitions for the instance variables

require 'prism'
require 'pathname'
require 'fileutils'

# Generate RBS instance variable definitions for memorized methods
class MemorizedIvarRbsGenerator
  Source = Data.define(:file, :content, :prism_node)
  MemorizedMethod = Data.define(:class_name, :method_name, :ivar_name, :return_type, :file)

  def initialize(lib_path: 'lib', output_path: 'sig/generated-by-scripts', namespace_filter: nil)
    @lib_path = Pathname(lib_path)
    @output_path = Pathname(output_path)
    @namespace_filter = namespace_filter
  end

  def process
    memorized_methods = find_memorized_methods

    if memorized_methods.empty?
      puts 'No memorized methods found'
      return
    end

    puts "Found #{memorized_methods.size} memorized methods:"
    memorized_methods.each do |method|
      puts "  - #{method.class_name}##{method.method_name} -> @#{method.ivar_name}: #{method.return_type}"
    end

    generate_rbs_files(memorized_methods)
  end

  private

  def find_memorized_methods
    methods = []

    @lib_path.glob('**/*.rb').each do |file|
      content = file.read
      parsed = Prism.parse(content)

      source = Source.new(file: file, content: content, prism_node: parsed.value)
      visitor = MemorizedMethodVisitor.new(source, namespace_filter: @namespace_filter)
      parsed.value.accept(visitor)

      methods.concat(visitor.memorized_methods)
    end

    methods
  end

  def generate_rbs_files(memorized_methods)
    puts "\nGenerating RBS files..."
    FileUtils.mkdir_p(@output_path)

    content = []
    content << '# Generated RBS definitions for memorized instance variables'
    content << '# This file is automatically generated by script/generate-memorized-ivar-rbs.rb'
    content << ''

    # Group by class name
    grouped = memorized_methods.group_by(&:class_name)

    grouped.each do |class_name, methods|
      parts = class_name.split('::')
      indent_level = 0

      # Open namespaces
      parts[0...-1].each do |part|
        content << ('  ' * indent_level) + "module #{part}"
        indent_level += 1
      end

      # Class declaration with instance variables
      content << ('  ' * indent_level) + "class #{parts.last}"

      methods.each do |method|
        content << ('  ' * (indent_level + 1)) + "@#{method.ivar_name}: #{method.return_type}"
      end

      content << "#{'  ' * indent_level}end"

      # Close namespaces
      (parts.size - 1).times do
        indent_level -= 1
        content << "#{'  ' * indent_level}end"
      end

      content << ''
    end

    output_file = @output_path / 'memorized_ivars.rbs'
    File.write(output_file, content.join("\n"))
    puts "Generated #{output_file}"
  end

  # Visitor to find memorized methods in Ruby source
  class MemorizedMethodVisitor < Prism::Visitor
    attr_reader :source, :memorized_methods, :namespace_filter, :namespace

    def initialize(source, namespace_filter: nil)
      @source = source
      @namespace_filter = namespace_filter
      @memorized_methods = []
      @namespace = []
      @current_class = nil
      super()
    end

    def visit_class_node(node)
      class_name = extract_constant_name(node.constant_path)

      in_namespace(class_name, is_class: true) do
        super
      end
    end

    def visit_module_node(node)
      module_name = extract_constant_name(node.constant_path)

      in_namespace(module_name, is_class: false) do
        super
      end
    end

    def visit_def_node(node)
      return unless @current_class

      # Skip if namespace filter is set and doesn't match
      return if @namespace_filter && !@current_class.start_with?(@namespace_filter)

      # Check for memorized annotation
      if memorized_annotated?(node)
        method_name = node.name.to_s

        # Extract instance variable name and return type
        ivar_info = extract_ivar_and_type(node)

        if ivar_info
          @memorized_methods << MemorizedIvarRbsGenerator::MemorizedMethod.new(
            class_name: @current_class,
            method_name: method_name,
            ivar_name: ivar_info[:ivar_name],
            return_type: ivar_info[:return_type],
            file: source.file
          )
        end
      end

      super
    end

    private

    def extract_constant_name(constant_path)
      case constant_path
      when Prism::ConstantReadNode
        constant_path.name.to_s
      when Prism::ConstantPathNode
        constant_path.name.to_s
      end
    end

    def in_namespace(name, is_class: false)
      if name
        @namespace << name
        old_class = @current_class
        @current_class = @namespace.join('::') if is_class
        yield
        @current_class = old_class
        @namespace.pop
      else
        yield
      end
    end

    def memorized_annotated?(node)
      return false unless node.location

      lines = source.content.lines
      method_line = node.location.start_line

      # Check the line before the method definition
      return false if method_line <= 1

      comment_line = lines[method_line - 2] # -2 because line numbers are 1-based
      return false unless comment_line

      comment_line.include?('@rbs %a{memorized}') || comment_line.include?('@rbs %a{ memorized }')
    end

    def extract_ivar_and_type(node)
      return nil unless node.body

      # Find instance variable assignments in the method body
      ivar_name = find_ivar_assignment(node.body)
      return nil unless ivar_name

      # Extract return type from the method signature comment if present
      return_type = extract_return_type_from_comment(node)

      {
        ivar_name: ivar_name,
        return_type: return_type || 'untyped'
      }
    end

    def find_ivar_assignment(node, depth = 0)
      case node
      when Prism::StatementsNode
        # Look through all statements
        node.body.each do |statement|
          result = find_ivar_assignment(statement, depth + 1)
          return result if result
        end
        nil
      when Prism::InstanceVariableOperatorWriteNode, Prism::InstanceVariableOrWriteNode
        # This handles @ivar ||= ...
        node.name.to_s.delete('@')
      when Prism::InstanceVariableWriteNode
        # This handles @ivar = ...
        node.name.to_s.delete('@')
      else
        # Recursively search in child nodes
        if node.respond_to?(:compact_child_nodes)
          node.compact_child_nodes.each do |child|
            result = find_ivar_assignment(child, depth + 1)
            return result if result
          end
        end
        nil
      end
    end

    def extract_return_type_from_comment(node)
      lines = source.content.lines
      method_line = node.location.start_line

      # Look for the method signature in the same line as def
      # Pattern: #: ReturnType or #: (...) -> ReturnType
      line = lines[method_line - 1] # -1 because line numbers are 1-based
      return nil unless line

      # Match patterns like "#: ChatThreadMessages" or "#: () -> ChatThreadMessages"
      if (match = line.match(/#:\s*(?:\([^)]*\)\s*->\s*)?(.+)/))
        return match[1].strip
      end

      nil
    end
  end
end

# Run if executed directly
if __FILE__ == $PROGRAM_NAME
  generator = MemorizedIvarRbsGenerator.new(namespace_filter: 'Ruboty')
  generator.process
end
